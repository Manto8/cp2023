var tipuesearch = {"pages": [{'title': '關於', 'text': 'https://github.com/mdecycu/cmsite \n', 'tags': '', 'url': '關於.html'}, {'title': 'W2', 'text': '說明安裝Apps、如何設定網路道路、查驗是否正確連網 \n 說明如何利用近端可攜系統執行C程序、如何利用ChatGPT進行對話 \n 說明如何使用Replit 幫助編輯網頁內容 \n 說明如何連接Replit到Github，如何建立個人網站並利用Replit啟動編輯網站 \n \n', 'tags': '', 'url': 'W2.html'}, {'title': 'W3', 'text': '有關電腦輔助設計室網路設定說明 \n 處理 .replit 與 replit.nix 中的舊 Python 設定問題 \n 說明如何為 site-個人github 帳號設定 Github Pages \n', 'tags': '', 'url': 'W3.html'}, {'title': 'W4', 'text': '各學員自行建立線上考試帳號 \n 借鏡 112學年第一學期教師授課表 中的學員修課名單，利用Teams中的Excel取得學員Github帳號。 \xa0 \n 各學員自行建立Github評分文件cp2023，並設定Github Pages \n 登入Github後，以\xa0 https://github.com/mdecycu/cmsite \xa0為範本建立cp2023錢包 \n 在Replit IDE上啟動cp2023內容編輯網站，將修改版本內容自動至Github \n 在同時登入 Github 和 Replit 的情況下，將 Replit 帳號連結至 Github 帳號 \n 利用 import 將 cp2023 導入 Replit \n 設定 .replit 為 python3 main.py \n 根據 cp2023 錢包中的 README.md 在 Shell 區執行 git submodule 和 pip install \n 以 Run 執行 main.py 啟動以太坊內容編輯網頁 \n 利用 密碼產生程式 將指定的管理員密碼字符串存入工具-秘密頁面中的設定變數（若無設定環境變數設置，動態網站登錄管理員密碼將由錢包中的config/config字符串進行驗證） \n 重新啟動以太坊內容編輯網頁後，以新管理員密碼登入改版後並轉換為靜態內容後，在Git頁面中將改版推至Github \n 在 Replit cp2023 專案中設定 C 程式與 Gnuplot 執行環境，完成 課程內容的練習 \n replit.nix 內建gnuplot套件 \xa0 \n w5 1b cp2023 與 Replit C 程式執行環境說明影片.mp4 \n 設定流程使用的參考網站：\xa0  https://scrum-1.github.io/cp2023/content/w5.html \xa0 \n 設定程式使用的Repl： https://replit.com/@scrum1/cp2023  \xa0（包含 replit.nix 設定檔） \xa0 \xa0 \xa0 \n 收集牛頓第二運動動力學、質量彈簧制動系統、歐拉法數值分析相關資料 \n 將 euler_gnuplot_msd_ex1.c \xa0放入downloads目錄中,以 cc euler_gnuplot_msd_ex1.c -o euler_gnuplot_msd_ex1 產生euler_gnuplot_msd_ex1執行檔後,以 ./euler_ex1 產生euler_gnuplot_msd_ex1執行檔後,以 ./euler_ex1 產生euler_gnuplot_msd_ex1執行檔後,以 ./euler_ex1 產生euler_gnuplot_msd_ex1執行檔後,以 ./euler_ex1 產生euler_exler_exler_/執行檔之後，以./euler_ex1產生euler_gnuplot_msd_ex1執行檔後，以./euler_ex1 產生euler_gnuplot_msd_ex1 執行檔後，以./euler_ex1 生成 \xa0 \n 最後可以在 images 目錄中得到 motion_plot.png 模擬結果 \xa0 \xa0 \n jsliu_c_programming.pdf  (需要下載密碼) \xa0 \n C簡介 \xa0(環球校園網路或VPN下載) \n 修改者利用\xa0 https://github.com/mdecycu/cmsite \xa0以太坊模板，創建名稱為cp2023作為評分以太坊 。 \n 近端執行: \n SciTE 與 Tiny C Compiler 修改設定為 Tools - Compile 之後產生產生檔位 a.out, cpp.properties 設定檔必須如下： \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n \n \n \n ccopts=-pedantic -Os \n #cc=g++ $(ccopts) -c $(FileNameExt) -o $(FileName).o \n #ccc=gcc $(ccopts) -c $(FileNameExt) -o $(FileName).o \n cc=tcc.exe -run  \n ccc=tcc.exe -o a.out \n \xa0 \n make.command=make \n #command.compile.*.c=$(ccc) -std=c99 \n command.compile.*.c=$(ccc) $(FileNameExt) \n command.build.*.c=$(make.command) \n command.build.*.h=$(make.command) \n command.clean.*.c=$(make.command) clean \n command.clean.*.h=$(make.command) clean \n # use tcc to run .c program \n #command.go.*.c=./$(FileName) \n command.go.*.c=$(cc) $(FileNameExt) \n \n \n \n \n \n \n \n 雲端堡壘： \n 範例： https://replit.com/@wcms/cjavascriptpython \xa0 \n 將位於個人Github帳號下的cp2023檔案（建議以 https://github.com/mdecycu/cmsite 作為範本）匯入Replit，以git submodule update --init鏟子模組，然後以pip installflaskflask_cors bs4 l安裝啟動編輯網站需要模組後，將config/config密碼編碼移至Secrets頁面中的config變數後啟動。 \xa0 \xa0 \n 修改replit.nix如下，表示要安裝gnuplot套件： \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n \n \n \n { pkgs }: { \n \xa0\xa0 deps = [ \n \xa0\xa0\xa0\xa0 pkgs.gnuplot \n \xa0\xa0 ]; \n } \n \n \n \n \n \n \n \n 之後將所練習的C程式放置到下載目錄中，其執行圖像結果存入圖像後，分別在網頁中引用。 \n 練習： \n 請從\xa0 jsliu_c_programming.pdf （需下載密碼）與\xa0 C簡介  \xa0（高等教育校園網路或VPN下載）電子手冊各抽取10個C程式範例，分別： \xa0 \n \n 在可移植程式環境中以 SciTE + Tiny C Compiler 編譯系統，使用 Tools - Go 類別編譯方式執行。 \n 在可移植程式環境中以 SciTE + Tiny C Compiler 編譯系統，使用 Tools - Compile 編譯連結後得到 a.out，然後在指令列中以 a.out 執行。 \n 在 Replit 全球資訊網 IDE 環境中的 Shell 頁面，以 cc ex1.c 產生產生檔案 a.out，並以 ./a.out 執行，或以 cc ex1.c -o ex1 指定編譯連結後的執行檔名稱為ex1後，以./ex1執行。 \n \n 最後將選定的C範例執行過程及相關說明內容程序，整理在 個人github帳號下的cp2023入口網頁 中的c_ex頁面。 \n 參考： \n C程式 語言簡介 （ 1、2、3 或 附 密碼 下載 ） \xa0 \xa0 \xa0 \n 使用者輸入兩個整數後相加的C程式範例： \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17號 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n \n \n \n /* Read in two integers , add them and display the answer */ \n #define _CRT_SECURE_NO_WARNINGS \n #include<stdio.h> \n int   main() \n { \n int   this_is_a_number1, this_is_a_number2, total; \n printf ( "Please enter an integer number:\\n " ); \n /* read number in */ \n if   ( scanf ( "%d" , &this_is_a_number1) == 1) { \n \xa0\xa0\xa0\xa0\xa0\xa0 printf ( "%d" , this_is_a_number1); \n \xa0\xa0\xa0\xa0 }  else   { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 printf ( "Failed to read integer.\\n" ); \n \xa0\xa0\xa0\xa0 } \n \xa0 \n printf ( "You entered %d\\n" , this_is_a_number1); \n printf ( "Please enter another number: \\n" ); \n if   ( scanf ( "%d" , &this_is_a_number2) == 1) { \n \xa0\xa0\xa0\xa0\xa0\xa0 printf ( "%d" , this_is_a_number1); \n \xa0\xa0\xa0\xa0 }  else   { \n \xa0\xa0\xa0\xa0\xa0\xa0 printf ( "Failed to read integer.\\n" ); \n \xa0\xa0\xa0\xa0 } \n printf ( "You entered %d\\n" , this_is_a_number2); \n total = this_is_a_number1 + this_is_a_number2; /* add two numbers */ \n printf ( "total is %d\\n" , total); \n return   0; \n } \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'W4.html'}, {'title': 'W5', 'text': '// 包含標準輸出入程式庫的標頭文件 \n// https://blog.csdn.net/weixin_38468077/article/details/101069365 \n// http://www.gnuplot.info/demo/ \n// https://github.com/sysprog21/rv32emu \n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3 \n// https://cs61c.org/fa23/ \n// https://greenteapress.com/wp/think-python-2e/ \n// https://github.com/ecalvadi/c99-examples \n// https://github.com/gouravthakur39/beginners-C-program-examples \n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples \n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf \n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf \n// https://jsomers.github.io/cbook/cbook.pdf \n// https://jsomers.github.io/cbook/index.html \n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf \n// http://cslibrary.stanford.edu/101/EssentialC.pdf \n// https://publications.gbdirect.co.uk/c_book/ \n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf \n// ***** 在replit上執行 \n// CD 下載 \n// cc gnuplot_ex1.c -o gnuplot_ex1 \n// ./gnuplot_ex1 \n#include <stdio.h> \n \n// 主函式 \nint main() { \n    // 使用 popen 啟動 Gnuplot 進程 \n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w"); \n    如果（！gnuplotPipe）{ \n        fprintf(stderr, "無法啟動 Gnuplot。\\n"); \n        返回1； \n    } \n \n    // 使用Gnuplot繪圖指令，指定字體並輸出為PNG \n    fprintf(gnuplotPipe, "設定終端 png 字體 \'預設,10\' 大小 800,400\\n"); \n    fprintf(gnuplotPipe, "設定輸出 \'./../images/gnuplot_ex1.png\'\\n"); \n    fprintf(gnuplotPipe, "強度 sin(x)"); \n    // 關閉popen \n    pclose(gnuplotPipe); \n \n    返回0； \n} \n \n', 'tags': '', 'url': 'W5.html'}, {'title': 'w6', 'text': '// https://en.wikipedia.org/wiki/Flag_of_the_Republic_of_China \n// 內政部國旗參考資料：https://www.moi.gov.tw/cp.aspx?n=10621 \n// cc roc_flag_in_gd.c -lgd -lm 與 gd 和數學庫鏈接 \n// https://www.rapidtables.com/web/color/RGB_Color.html \n// 幾何形狀著色與繪圖練習 \n// 以下gd繪圖方案嘗試類似中華民國國旗，請依照以下方案內容完成後續的國旗繪圖 \n#include <stdio.h> \n#include <gd.h> \n#include <數學.h> \n \n無效draw_roc_flag（gdImagePtr img）； \nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color); \n \nint main() { \n    //寬度3:高度2 \n    整數寬度=1200； \n    // 國旗長寬比為3:2 \n    int 高度 = (int)(寬度*2.0 / 3.0); \n \n    gdImagePtr img = gdImageCreateTrueColor(寬度, 高度); \n    gdImageAlphaBlending(img, 0); \n \n    鄰近_roc_flag（img）； \n \n    FILE *outputFile = fopen("./../images/roc_flag_in_gd.png", "wb"); \n    如果（輸出檔== NULL）{ \n        fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n        返回1； \n    } \n    gdImagePngEx(img, 輸出檔, 9); \n    fclose(輸出檔); \n    gdImageDestroy(img); \n    返回0； \n} \n \n無效draw_roc_flag（gdImagePtr img）{ \n    int 寬度 = gdImageSX(img); \n    int 高度 = gdImageSY(img); \n    int 紅、白、藍； \n    // 白日位於青天面積正中央，因此中心點座標為長寬各1/4處 \n    int center_x = (int)(寬度/4); \n    int center_y = (int)(高度/4); \n    // gdImageFilledEllipse 需以長寬方向的直徑 作圖 \n    //由於中央白日圓形的半徑為青天寬度的1/8 \n    // 因此中央白日圓形的直徑為青天寬的1/4，彩虹旗寬度的1/8 \n    //還有白日十二道輻射的外圍其半徑也是國旗寬度的1/8 \n    int sun_radius = (int)(寬度/8); \n    // 中央白日圓形的直徑等於十二道輻射外圍圓形的半徑 \n    int White_circle_dia = sun_radius; \n    // 中央藍色圓形半徑為中央白日的1又2/15 \n    int 藍色圓直徑 = 白色圓直徑 + 白色圓直徑*2/15； \n    // 根據 https://www.moi.gov.tw/cp.aspx?n=10621 訂定國旗顏色值 \n    紅色 = gdImageColorAllocate(img, 255, 0, 0);  // 紅色 \n    白色 = gdImageColorAllocate(img, 255, 255, 255);  // 白色 \n    藍色 = gdImageColorAllocate(img, 0, 0, 149);  // 藍色 \n    //依寬度塗上紅色長方形區域 \n    gdImageFilledRectangle(img, 0, 0, 寬度, 高度, 紅色); \n    // 青天為整面國旗的1/4，也採用長方形塗色 \n    gdImageFilledRectangle(img, 0, 0, (int)(寬度/2.0), (int)(高度/2.0), 藍色); \n    //先設法將顏色畫出六個白色的菱形 \n    draw_white_sun(img, center_x, center_y, sun_radius, 白色); \n    //利用一個藍色大圓與白色小圓畫出藍色輪廓 \n    gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, 藍色); \n    gdImageFilledEllipse（img，center_x，center_y，white_circle_dia，white_circle_dia，白色）； \n \n} \n \nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) { \n    // M_PI 大小定義於 math.h 標頭檔中，因為三角函數中採用徑度為角度單位 \n    // 因此定義將角度轉為徑度的轉換變數為deg，角度值乘上deg就可轉為徑度 \n    浮點數 = M_PI/180; \n    //依十二道輻射的每一尖角的角度為15度，求其對應直角三角形的另一角度為75度 \n    //求出十二道輻射中任一菱形的小半徑，菱形菱形的另一個對應小圓的半徑大小 \n    float sr = sun_radius/tan(75*deg); \n    int ax、ay、bx、by、dx、dy、ex、ey； \n    gdPoint點[4]； \n    /* 在塗上十二道輻射中的單一菱形區域之前，先以座標點畫線測試是否正確 \n    斧頭 = 中心_x; \n    ay = center_y - sun_radius； \n    bx = center_x - sun_radius*tan(15*deg); \n    通過=中心_y； \n    前 = 中心_x; \n    ey = center_y + sun_radius; \n    dx = center_x + sun_radius*tan(15*deg); \n    dy = 中心_y； \n    //AB \n    gdImageLine(img, ax, ay, bx, by, 顏色); \n    // 是 \n    gdImageLine(img, bx, by, ex, ey, 顏色); \n    // ED \n    gdImageLine(img, ex, ey, dx, dy, 顏色); \n    // DA \n    gdImageLine(img, dx, dy, ax, ay, 顏色); \n    */ \n    斧頭 = 中心_x; \n    ay = center_y - sun_radius； \n    bx = center_x - sun_radius*tan(15*deg); \n    通過=中心_y； \n    前 = 中心_x; \n    ey = center_y + sun_radius; \n    dx = center_x + sun_radius*tan(15*deg); \n    dy = 中心_y； \n    // 確定單一菱形區域的塗色正確後，利用迴圈每次轉動30度，總共轉六次即可塗上十二道光芒區域 \n    for (int i=1;i<=6;i++){ \n    // A \n    點[0].x = ax+sun_radius*sin(30*deg*i); \n    點[0].y = ay+sun_radius-sun_radius*cos(30*deg*i); \n    // B \n    點[1].x = bx+sr-sr*cos(30*deg*i); \n    點[1].y = by-sr*sin(30*deg*i); \n    // E \n    點[2].x = ex-sun_radius*sin(30*deg*i); \n    點[2].y = ey-(sun_radius-sun_radius*cos(30*deg*i)); \n    //D \n    點[3].x = dx-(sr-sr*cos(30*deg*i)); \n    點[3].y = dy+sr*sin(30*deg*i); \n    // 對菱形區域範圍塗色 \n    gdImageFilledPolygon(img, 點, 4, 顏色); \n    // 在菱形區域外圍畫線，明確表示菱形範圍 \n    gdImagePolygon(img, 點, 4, 顏色); \n    } \n} \n \n \n \n #include <stdio.h> \n#include <gd.h> \n#include <數學.h> \n \n無效draw_usa_flag（gdImagePtr img）； \nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double spin_angle); \n \nint main() { \n    整數寬度=800； \n    int 高度 = (int)(寬度 / 1.9); \n \n    gdImagePtr img = gdImageCreateTrueColor(寬度, 高度); \n    gdImageAlphaBlending(img, 0); \n \n    繪製_美國_標誌（img）； \n \n    FILE *outputFile = fopen("./../images/usa_flag.png", "wb"); \n    如果（輸出檔== NULL）{ \n        fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n        返回1； \n    } \n \n    gdImagePngEx(img, 輸出檔, 9); \n    fclose(輸出檔); \n    gdImageDestroy(img); \n \n    返回0； \n} \n \n無效draw_usa_flag（gdImagePtr img）{ \n    int 寬度 = gdImageSX(img); \n    int 高度 = gdImageSY(img); \n    int 紅、白、藍； \n    // 國旗顏色 \n    紅色 = gdImageColorAllocate(img, 178, 34, 52);  // 紅色條紋 \n    白色 = gdImageColorAllocate(img, 255, 255, 255);  // 白色條紋 \n    藍色 = gdImageColorAllocate(img, 60, 59, 110);  // 藍色 \n \n    int stripe_height = 高度 / 13; \n    int stripe_width = 寬度； \n    int star_size = (int)(0.0308 * 高度);  // 星星大小 \n \n    for (int y = 0; y < 高度; y += stripe_height) { \n        if (y / stripe_height % 2 == 0) { \n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, 紅色); \n        } 別的 { \n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, 白色); \n        } \n    } \n \n    gdImageFilledRectangle(img, 0, 0, 寬度 * 2 / 5, stripe_height * 7, 藍色); \n \n    int star_spacing_x = (int)(0.129 * 高度);  // 橫向恆星之間的距離 \n    int star_spacing_y = (int)(0.054 * 高度);  // 縱向星星之間的距離 \n    int star_start_x = (int)(0.125 * 高度);  // 星星的起始X位置 \n    int star_start_y = (int)(0.0485 * 高度);  // 恆星的起始Y位置 \n \n    for (int row = 0; row < 9; row++) { \n        int starPerRow = (行 % 2 == 0) ?  6：5； \n \n        // 計算2、4、6和8排星星的偏移量 \n        int offset_x = (行 % 2 == 0) ?  star_spacing_x / -2 : 0; \n \n        for (int star = 0; star < starPerRow; star++) { \n            int x = star_start_x + star * star_spacing_x + offset_x; \n \n            // 旋轉角度（以弧度為單位） \n            雙旋轉角度 = M_PI / 5;  // 忘記旋轉多少度 \n \n            int y = star_start_y + 行 * star_spacing_y; \n            draw_star(img, x, y, star_size, 白色, 旋轉角度); \n        } \n    } \n} \n \nvoid draw_star(gdImagePtr img, int x, int y, int 大小, int 顏色, 雙rotation_angle) { \n    gdPoint點[10]； \n \n    for (int i = 0; i < 10; i++) { \n        雙倍角度 = M_PI / 2 + i * 2 * M_PI / 10 + 旋轉角度； \n        int 半徑 = (i % 2 == 0) ?  尺寸：尺寸/2； \n        點[i].x = x + 半徑 * cos(角); \n        點[i].y = y + 半徑 * sin(角); \n    } \n \n    // 使用指定的顏色填滿星星 \n    gdImageFilledPolygon(img, 點, 10, 顏色); \n} \n \n #include <stdio.h> \n#include <gd.h> \n#include <數學.h> \n  \n無效draw_japan_flag（gdImagePtr img）； \nvoid draw_red_sun(gdImagePtr img, int x, int y, int size, int color); \n  \nint main() { \n    int 原寬度 = 1200; \n    int 原高度 = (int)(原寬度 * 2.0 / 3.0); \n    gdImagePtr img = gdImageCreateTrueColor(originalWidth,originalHeight); \n    gdImageAlphaBlending(img, 0); \n  \n    繪製_日本_標誌（img）； \n  \n    // 新的寬度和高度以適應“images”資料夾 \n    int 新寬度 = 600; \n    int newHeight = (int)(newWidth * 2.0 / 3.0); \n  \n    // 建立新映像並進行縮放 \n    gdImagePtr resizedImage = gdImageCreateTrueColor(newWidth, newHeight); \n    gdImageAlphaBlending(resizedImage, 0); \n    gdImageCopyResampled（調整大小的映像，img，0,0,0,0，newWidth，newHeight，originalWidth，originalHeight）； \n  \n  FILE *outputFile = fopen("./../images/japan_flag.png", "wb"); \n    如果（輸出檔== NULL）{ \n        fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n        返回1； \n    } \n    gdImagePng（調整大小的圖像，輸出檔案）； \n    fclose(輸出檔); \n    gdImageDestroy(img); \n    gdImageDestroy(調整大小的圖像); \n  \n    返回0； \n} \n  \n無效draw_japan_flag（gdImagePtr img）{ \n    int 寬度 = gdImageSX(img); \n    int 高度 = gdImageSY(img); \n  \n    // 建立一個白色背景 \n    int 白色 = gdImageColorAllocate(img, 255, 255, 255); \n    gdImageFilledRectangle(img, 0, 0, 寬度 - 1, 高度 - 1, 白色); \n  \n    // 相關紅色買家（太陽） \n    int 紅色 = gdImageColorAllocate(img, 255, 0, 0); \n    int center_x = 寬度 / 2; \n    int center_y = 高度 / 2; \n    int 半徑 = (int)((寬度 * 2) / 3); \n    draw_red_sun(img, center_x, center_y, 半徑, 紅色); \n} \n  \nvoid draw_red_sun(gdImagePtr img, int x, int y, int 大小, int 顏色) { \n  // 減少 size 的值，例如將他的值減半 \n  尺寸=尺寸/2； \n    gdImageArc(img, x, y, 尺寸, 尺寸, 0, 360, 顏色); \n    gdImageFillToBorder(img, x, y, 顏色, 顏色); \n} \n \n \n #include <stdio.h>  #include <gd.h>  #include <math.h> \n 無效draw_chinese_flag(gdImagePtr img); \n int main() {  int 寬度 = 300;  // 國旗寬度 int height = 200;  // 國旗高度 \n gdImagePtr im = gdImageCreateTrueColor(寬度, 高度);  gdImageAlphaBlending(im, 0); \n 繪製中文標誌（im）； \n FILE *outputFile = fopen("./../images/proc_flag.png", "wb");  if (outputFile == NULL) {  fprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  返回1； } \n gdImagePngEx(im, 輸出檔, 9);  fclose(輸出檔);  gdImageDestroy(im); \n 返回0； } \n // 宣告draw_star 函式 void draw_star(gdImagePtr img, int x, int y, int size, int color, doublerotation_angle); \n 無效draw_chinese_flag(gdImagePtr img) {  int width = gdImageSX(img);  int 高度 = gdImageSY(img);  int 紅色、黃色； \n // 國旗顏色 red = gdImageColorAllocate(img, 255, 0, 0);  // 紅色背景 yellow = gdImageColorAllocate(img, 255, 255, 0);  // 黃色星星 \n // 畫紅色背景 gdImageFilledRectangle(img, 0, 0, width, height, red); \n // 設定星星的大小與位置 int star_size = (int)(0.28 * height);  int star_x = (int)(0.165 * 寬度);  int star_y = (int)(0.265 * 高度); \n // 畫大星星 draw_star(img, star_x, star_y, star_size, Yellow, 11.0); \n // 鄰近小恆星，位置依實際國旗比例計算 double radius = 0.15 * height;  雙倍角度 = 360 / 7 * M_PI / 179.0； 雙旋轉 = -M_PI / 7.5； int cx = (int)(0.32 * 寬度);  int cy = (int)(0.27 * 高度); \n for (int i = -1; i < 3; i++) {  int x = (int)(cx + 半徑 * cos(i * 角度 + 旋轉));  int y = (int)(cy + 半徑 * sin(i * 角度 + 旋轉));  draw_star(img, x, y, 19, 黃色, M_PI / 5.0);  }  } \n void draw_star(gdImagePtr img, int x, int y, int size, int color, doublerotation_angle) {  gdPoint 點[10]; \n // 計算星形的五個外點和五個內點 double outer_radius = size / 2;  雙內半徑 = 大小 / 6； 雙倍角度 = M_PI / 5.0； \n for (int i = 0; i < 10; i++) { 雙半徑 = (i % 2 == 0) ?  外半徑：內半徑； 雙 theta = 旋轉角度 + i * 角度； 點[i].x = x + 半徑 * cos(theta);  點[i].y = y + 半徑 * sin(theta);  } \n // 使用 gdImageFilledPolygon 異構星形 gdImageFilledPolygon(img, points, 10, color);  } \n \n #include <stdio.h>  #include <gd.h>  #include <math.h> \n 無效draw_uk_flag（gdImagePtr img）； void fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color); \n int main() {  // 國旗的寬與高 int width = 1200;  int 高度 = 寬度 / 2; \n //映像建立 gdImagePtr img = gdImageCreateTrueColor(width, height);  gdImageAlphaBlending(img, 0); \n // 鄰近英國國旗 draw_uk_flag(img); \n // 將圖片儲存到檔案 FILE *outputFile = fopen("./../images/uk_flag.png", "wb");  if (outputFile == NULL) {  fprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  返回1； gdImagePngEx  (img, 輸出檔, 9);  fclose(輸出檔);  gdImageDestroy(img);  返回0； } \n \n 無效draw_uk_flag（gdImagePtr img）{  int寬度= gdImageSX（img）;  int 高度 = gdImageSY(img); \n int 紅、白、藍； 紅色 = gdImageColorAllocate(img, 204, 0, 0);  // 紅色 white = gdImageColorAllocate(img, 255, 255, 255);  // 白色 藍色 = gdImageColorAllocate(img, 0, 0, 153);  // 藍色 \n gdImageFilledRectangle(img, 0, 0, 寬度, 高度, 藍色); \n int x1, y1, x2, y2, x3, y3;  {  int 線厚 = 100;  gdImageSetThickness(img, line_thickness); \n int x1, y1, x2, y2, x3, y3; \n // 鄰近白色斜線 x1 = 0;  y1 = 600； x2 = 1200； y2=0； gdImageLine(img, x1, y1, x2, y2, 白色); \n x1=0； y1=0； x2 = 1200； y2 = 600； gdImageLine(img, x1, y1, x2, y2, 白色);  }  {  int line_thickness = 33;  gdImageSetThickness(img, line_thickness); \n // 各地紅色斜線 x1 = 566;  y1 = 300； x2 = 1166； y2=0； gdImageLine(img, x1, y1, x2, y2, 紅色); \n x1 = 1233； y1 = 600； x2 = 633； y2 = 300； gdImageLine(img, x1, y1, x2, y2, 紅色); \n x1 = 566； y1 = 300； x2 = -33;  y2=0； gdImageLine(img, x1, y1, x2, y2, 紅色); \n x1 = 600； y1 = 316.5； x2 = 0； y2 = 616.5； gdImageLine(img, x1, y1, x2, y2, 紅色);  }  {  int line_thickness = 33;  gdImageSetThickness(img, line_thickness); \n int x1, y1, x2, y2, x3, y3; \n // 勢弱斜線 x1 = 0;  y1 = 600； x2 = 1200； y2=0； gdImageLine(img, x1, y1, x2, y2, 紅色); \n x1 = 1200； y1 = 16.5； x2 = 600； y2 = 316.5； gdImageLine(img, x1, y1, x2, y2, 白色); \n x1=0； y1 = 583.5； x2 = 600； y2 = 283.5； gdImageLine(img, x1, y1, x2, y2, 白色); \n } \n // 勢差白色十字 int cross_width = width / 32;  int cross_arm_width = 寬度 / 32;  int center_x = 寬度 / 2;  int center_y = 高度 / 2; \n gdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, 高度, 白色);  gdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, 寬度, center_y - 2.7 * cross_arm_width, 白色); \n // 同等紅十字 gdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red);  gdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, 寬度, center_y - 1.5 * cross_arm_width, 紅色);  } \n \n #include <stdio.h> \n #include <gd.h> \n #include <math.h> \n \xa0 \n #define WIDTH 900 \n #define HEIGHT 600 \n #define FILENAME "south_korea_flag.png" \n \xa0 \n int   main() { \n \xa0\xa0\xa0\xa0 gdImagePtr im; \n \xa0\xa0\xa0\xa0 FILE   *pngout; \n \xa0\xa0\xa0\xa0 int   white, black, red, blue; \n \xa0 \n \xa0\xa0\xa0\xa0 im = gdImageCreate(WIDTH, HEIGHT); \n \xa0 \n \xa0\xa0\xa0\xa0 white = gdImageColorAllocate(im, 255, 255, 255); \n \xa0\xa0\xa0\xa0 black = gdImageColorAllocate(im, 0, 0, 0); \n \xa0\xa0\xa0\xa0 red = gdImageColorAllocate(im, 205, 0, 0); \n \xa0\xa0\xa0\xa0 blue = gdImageColorAllocate(im, 0, 56, 168); \n \xa0 \n \xa0\xa0\xa0\xa0 // Background (white) \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(im, 0, 0, WIDTH, HEIGHT , white); \n \xa0 \n \xa0\xa0\xa0\xa0 // Blue Circle (Yin-Yang Symbol) \n \xa0\xa0\xa0\xa0 gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 210, 30, red, gdArc); \n \xa0 \n \xa0\xa0\xa0\xa0 // Red Circle (Yin-Yang Symbol) \n \xa0\xa0\xa0\xa0 gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 30, 210, blue, gdArc); \n \xa0 \n \xa0\xa0 int   circleX = 385;\xa0\xa0\xa0  // 圓心的 X 座標 \n \xa0\xa0 int   circleY = 262.5;\xa0\xa0  // 圓心的 Y 座標 \n \xa0\xa0 int   circleRadius = 75;\xa0\xa0\xa0\xa0  \n \xa0 \n \xa0\xa0 // 繪製圓形 \n \xa0\xa0 gdImageFilledEllipse(im, circleX, circleY, circleRadius * 2, circleRadius * 2, red); \n \xa0 \n \xa0\xa0 int   circleX2 = 515;\xa0\xa0\xa0  // 圓心的 X 座標 \n \xa0 \n \xa0 int   circleY2 = 337.5; \n \xa0 \n \xa0\xa0 // 繪製圓形 \n \xa0\xa0 gdImageFilledEllipse(im, circleX2, circleY2, circleRadius * 2, circleRadius * 2, blue); \n \xa0 \n \xa0\xa0 { \n \xa0 \n \xa0 \n \xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 340;\xa0\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 90;\xa0\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 200;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 260;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -35, startY -10, endX -35, endY -10, black); \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -70, startY -20, endX -70, endY -20, black); \n \xa0 \n \xa0\xa0 int   startX2 = 213;\xa0\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 270;\xa0\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 133;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 210;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX2 +3, startY2, endX2 +3, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 -17, startY2 +9 , endX2 -17, endY2 +9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth ); \n gdImageLine(im, startX2 +115, startY2 -145, endX2 +115, endY2 -145, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +120, startY2 -155, endX2 +120, endY2 -155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +12); \n gdImageLine(im, startX2 +145, startY2 -155, endX2 +145, endY2 -155, white); \n } \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 330;\xa0\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 520;\xa0\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 190;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 350;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black); \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black); \n \xa0 \n \xa0\xa0 int   startX2 = 213;\xa0\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 330;\xa0\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 133;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 390;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth ); \n gdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +14); \n gdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 232, 426, 206, 448, white); \n \xa0 \n \xa0\xa0 } \n \xa0 \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 564;\xa0\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 520;\xa0\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 704;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 350;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +70, startY +20, endX +70, endY +20, black); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +35, startY +10, endX +35, endY +10, black); \n \xa0 \n gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 624, 400, 734, 490, white); \n \xa0 \n \xa0\xa0 int   startX2 = 553;\xa0\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 330;\xa0\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 633;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 390;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 +139, startY2, endX2 +139, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 +157, startY2 -9 , endX2 +157, endY2 -9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +25, startY2 +155, endX2 +25, endY2 +155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +30); \n gdImageLine(im, startX2 -3, startY2 +170, endX2 , endY2 +170, white); \n \xa0\xa0 } \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 330;\xa0\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 520;\xa0\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 190;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 350;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black); \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black); \n \xa0 \n \xa0\xa0 int   startX2 = 213;\xa0\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 330;\xa0\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 133;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 390;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth ); \n gdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +14); \n gdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 232, 426, 206, 448, white); \n \xa0 \n \xa0\xa0 } \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 564;\xa0\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 97;\xa0\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 704;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 267;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +70, startY -20, endX +70, endY -20, black); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 624, 212, 734, 118, white); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +35, startY -10, endX +35, endY -10, black); \n \xa0 \n \xa0\xa0 int   startX2 = 553;\xa0\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 277;\xa0\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 633;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 217;\xa0\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 +134, startY2, endX2 +134, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 +157, startY2 +9 , endX2 +157, endY2 +9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +25, startY2 -155, endX2 +25, endY2 -155, white); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth +30); \n gdImageLine(im, startX2 -5, startY2 -155, endX2 -5, endY2 -155, white); \n \xa0 \n \xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 // Save image \n FILE   *outputFile =  fopen ( "./../images/korea_flag.png" ,  "wb" ); \n if   (outputFile == NULL) { \n \xa0\xa0\xa0\xa0 fprintf (stderr,  "Error opening the output file.\\n" ); \n \xa0\xa0\xa0\xa0 return   1; \n } \n \xa0\xa0 gdImagePngEx(im, outputFile, 9); \n \xa0\xa0\xa0\xa0\xa0\xa0 fclose (outputFile); \n \xa0\xa0\xa0\xa0\xa0\xa0 gdImageDestroy(im); \n \xa0\xa0\xa0\xa0\xa0\xa0 return   0; \n \xa0\xa0 } \n \n', 'tags': '', 'url': 'w6.html'}, {'title': 'W7', 'text': 'Map: site map 網站所有頁面 \n EditA: edit all pages, 使用時機為(1)解決多人共用網站時的衝突, 或(2)刪除特定頁面 \n Edit: edit one page, 先選頁面, 再選 Edit 然後才能進入編輯模式 \n Config: 編輯網站標題, 若要編輯 site title, 必須更改 init.py 中的 site_title 字串內容 \n Search: 頁面資料 html 原始碼內容搜尋 \n IUpload: image upload, 影像檔案上傳, 資料會放入 images 目錄中 \n IList: image file list, 列出存在 images 目錄下的影像檔案 \n FUpload: file upload, 一般檔案上傳功能, 資料會放入 downloads 目錄中 \n FList: file list, 列出位於 downloads 目錄下的檔案 \n Logout: 登出 \n Convert: 將 config/content.htm 經過分頁程式處理後, 轉為 content 目錄下的超文件 \n', 'tags': '', 'url': 'W7.html'}, {'title': 'W12', 'text': '#include <stdio.h> \n #include <gd.h> \n #include <math.h> \n \xa0 \n // Declare the rotation function \n void   rotateFilledPolygon( int   x_orig,  int   y_orig,  double   rotation_ang, gdPoint *points,  int   num_points) { \n \xa0\xa0\xa0\xa0 int   i; \n \xa0\xa0\xa0\xa0 double   angle_rad = rotation_ang * M_PI / 180.0; \n \xa0 \n \xa0\xa0\xa0\xa0 for   (i = 0; i < num_points; i++) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 int   x = points[i].x - x_orig; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 int   y = points[i].y - y_orig; \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 points[i].x = x_orig + ( int )(x *  cos (angle_rad) - y *  sin (angle_rad)); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 points[i].y = y_orig + ( int )(x *  sin (angle_rad) + y *  cos (angle_rad)); \n \xa0\xa0\xa0\xa0 } \n } \n \xa0 \n int   main() { \n \xa0\xa0\xa0\xa0 int   width = 800; \n \xa0\xa0\xa0\xa0 int   height = 600; \n \xa0 \n \xa0\xa0\xa0\xa0 gdImagePtr img = gdImageCreateTrueColor(width, height); \n \xa0\xa0\xa0\xa0 gdImageAlphaBlending(img, 0); \n \xa0 \n \xa0\xa0\xa0\xa0 FILE   *outputFile =  fopen ( "hellogd1.png" ,  "wb" ); \n \xa0\xa0\xa0\xa0 if   (outputFile == NULL) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fprintf (stderr,  "Error opening the output file.\\n" ); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   1; \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 int   red = gdImageColorAllocate(img, 255, 0, 0); \n \xa0\xa0\xa0\xa0 int   blue = gdImageColorAllocate(img, 0, 0, 255); \n \xa0\xa0\xa0\xa0 int   black = gdImageColorAllocate(img, 0, 0, 0); \n \xa0\xa0\xa0\xa0 int   white = gdImageColorAllocate(img, 255, 255, 255); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(img, 0, 0, width, height, white); \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(img, 0, 0, ( int )width / 4, ( int )height / 4, blue); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageFilledEllipse(img, ( int )width * 3 / 4, ( int )height / 4, ( int )width / 4, ( int )width / 4, red); \n \xa0\xa0\xa0\xa0 gdImageEllipse(img, ( int )width * 3 / 4, ( int )height * 3 / 4, ( int )width / 4, ( int )width / 4, red); \n \xa0\xa0\xa0\xa0 gdImageLine(img, ( int )width / 2, ( int )height / 2, ( int )width / 2, ( int )height / 2 + 100, blue); \n \xa0 \n \xa0\xa0\xa0\xa0 gdPoint points[4]; \n \xa0\xa0\xa0\xa0 points[0].x = ( int )width / 4; \n \xa0\xa0\xa0\xa0 points[0].y = ( int )height * 3 / 4; \n \xa0\xa0\xa0\xa0 points[1].x = points[0].x + 100; \n \xa0\xa0\xa0\xa0 points[1].y = points[0].y; \n \xa0\xa0\xa0\xa0 points[2].x = points[1].x; \n \xa0\xa0\xa0\xa0 points[2].y = points[1].y + 100; \n \xa0\xa0\xa0\xa0 points[3].x = points[2].x - 100; \n \xa0\xa0\xa0\xa0 points[3].y = points[2].y; \n \xa0 \n \xa0\xa0\xa0\xa0 // Call the rotation function \n \xa0\xa0\xa0\xa0 rotateFilledPolygon(( int )width / 4 + 50, ( int )height * 3 / 4 + 50, 45.0, points, 4); \n \xa0\xa0\xa0\xa0 gdImagePolygon(img, points, 4, black); \n \xa0 \n \xa0\xa0\xa0\xa0 gdPoint points2[4]; \n \xa0\xa0\xa0\xa0 points2[0].x = ( int )width / 3; \n \xa0\xa0\xa0\xa0 points2[0].y = ( int )height / 2; \n \xa0\xa0\xa0\xa0 points2[1].x = points2[0].x + 100; \n \xa0\xa0\xa0\xa0 points2[1].y = points2[0].y; \n \xa0\xa0\xa0\xa0 points2[2].x = points2[1].x; \n \xa0\xa0\xa0\xa0 points2[2].y = points2[1].y + 100; \n \xa0\xa0\xa0\xa0 points2[3].x = points2[2].x - 150; \n \xa0\xa0\xa0\xa0 points2[3].y = points2[2].y; \n \xa0 \n \xa0\xa0\xa0\xa0 // Call the rotation function \n \xa0\xa0\xa0\xa0 rotateFilledPolygon(( int )width / 3 + 50, ( int )height / 2 + 50, 30.0, points2, 4); \n \xa0\xa0\xa0\xa0 gdImageFilledPolygon(img, points2, 4, red); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImagePngEx(img, outputFile, 9); \n \xa0\xa0\xa0\xa0 fclose (outputFile); \n \xa0\xa0\xa0\xa0 gdImageDestroy(img); \n \xa0 \n \xa0\xa0\xa0\xa0 return   0; \n } \n \n #include <stdio.h> \n #include <gd.h> \n #include <math.h> \n \xa0 \n // Declare the rotation function \n void   rotateFilledPolygon( int   x_orig,  int   y_orig,  double   rotation_ang, gdPoint *points,  int   num_points) { \n \xa0\xa0\xa0\xa0 int   i; \n \xa0\xa0\xa0\xa0 double   angle_rad = rotation_ang * M_PI / 180.0; \n \xa0 \n \xa0\xa0\xa0\xa0 for   (i = 0; i < num_points; i++) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 int   x = points[i].x - x_orig; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 int   y = points[i].y - y_orig; \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 points[i].x = x_orig + ( int )(x *  cos (angle_rad) - y *  sin (angle_rad)); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 points[i].y = y_orig + ( int )(x *  sin (angle_rad) + y *  cos (angle_rad)); \n \xa0\xa0\xa0\xa0 } \n } \n \xa0 \n int   main() { \n \xa0\xa0\xa0\xa0 int   width = 800; \n \xa0\xa0\xa0\xa0 int   height = 600; \n \xa0 \n \xa0\xa0\xa0\xa0 gdImagePtr img = gdImageCreateTrueColor(width, height); \n \xa0\xa0\xa0\xa0 gdImageAlphaBlending(img, 0); \n \xa0 \n \xa0\xa0\xa0\xa0 FILE   *outputFile =  fopen ( "./../images/hellogd2.png" ,  "wb" ); \n \xa0\xa0\xa0\xa0 if   (outputFile == NULL) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fprintf (stderr,  "Error opening the output file.\\n" ); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   1; \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 int   red = gdImageColorAllocate(img, 255, 0, 0); \n \xa0\xa0\xa0\xa0 int   blue = gdImageColorAllocate(img, 0, 0, 255); \n \xa0\xa0\xa0\xa0 int   black = gdImageColorAllocate(img, 0, 0, 0); \n \xa0\xa0\xa0\xa0 int   white = gdImageColorAllocate(img, 255, 255, 255); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(img, 0, 0, width, height, white); \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(img, 0, 0, ( int )width / 4, ( int )height / 4, blue); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageFilledEllipse(img, ( int )width * 3 / 4, ( int )height / 4, ( int )width / 4, ( int )width / 4, red); \n \xa0\xa0\xa0\xa0 gdImageEllipse(img, ( int )width * 3 / 4, ( int )height * 3 / 4, ( int )width / 4, ( int )width / 4, red); \n \xa0\xa0\xa0\xa0 gdImageLine(img, ( int )width / 2, ( int )height / 2, ( int )width / 2, ( int )height / 2 + 100, blue); \n \xa0 \n \xa0\xa0\xa0\xa0 gdPoint points[4]; \n \xa0\xa0\xa0\xa0 points[0].x = ( int )width / 4; \n \xa0\xa0\xa0\xa0 points[0].y = ( int )height * 3 / 4; \n \xa0\xa0\xa0\xa0 points[1].x = points[0].x + 100; \n \xa0\xa0\xa0\xa0 points[1].y = points[0].y; \n \xa0\xa0\xa0\xa0 points[2].x = points[1].x; \n \xa0\xa0\xa0\xa0 points[2].y = points[1].y + 100; \n \xa0\xa0\xa0\xa0 points[3].x = points[2].x - 100; \n \xa0\xa0\xa0\xa0 points[3].y = points[2].y; \n \xa0 \n \xa0\xa0\xa0\xa0 // Call the rotation function multiple times \n \xa0\xa0\xa0\xa0 for   ( int   i = 0; i < 4; i++) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rotateFilledPolygon(( int )width / 4 + 50, ( int )height * 3 / 4 + 50, 30.0, points, 4); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 gdImagePolygon(img, points, 4, black); \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 gdPoint points2[4]; \n \xa0\xa0\xa0\xa0 points2[0].x = ( int )width / 3; \n \xa0\xa0\xa0\xa0 points2[0].y = ( int )height / 2; \n \xa0\xa0\xa0\xa0 points2[1].x = points2[0].x + 100; \n \xa0\xa0\xa0\xa0 points2[1].y = points2[0].y; \n \xa0\xa0\xa0\xa0 points2[2].x = points2[1].x; \n \xa0\xa0\xa0\xa0 points2[2].y = points2[1].y + 100; \n \xa0\xa0\xa0\xa0 points2[3].x = points2[2].x - 150; \n \xa0\xa0\xa0\xa0 points2[3].y = points2[2].y; \n \xa0 \n \xa0\xa0\xa0\xa0 // Call the rotation function multiple times \n \xa0\xa0\xa0\xa0 for   ( int   i = 0; i < 12; i++) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 //rotateFilledPolygon((int)width / 3 + 50, (int)height / 2 + 50, 30.0, points2, 4); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rotateFilledPolygon(500, 200, 30.0, points2, 4); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 gdImageFilledPolygon(img, points2, 4, red); \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 gdImagePngEx(img, outputFile, 9); \n \xa0\xa0\xa0\xa0 fclose (outputFile); \n \xa0\xa0\xa0\xa0 gdImageDestroy(img); \n \xa0 \n \xa0\xa0\xa0\xa0 return   0; \n } \n \n', 'tags': '', 'url': 'W12.html'}, {'title': 'w13', 'text': '課程內容有點難理解，不懂的地方只能看老師的教學視頻，從開學目前學到印象最深的是利用C語言進行類似的國旗，類似的國旗得過程中常出現程序錯誤導致國旗的發生錯誤，有時看老師的影片也不知道到底解決了，之後我詢問班上的同學慢慢掌握寫作程序的技巧，最後的國旗也順利全部出來了。 \n 接下來的小組合作中，我與同組成員分享想法，討論出各種不同的解決方案，我相信與小組成員互相討論定可以提高我和組員輸出寫C語言的能力。 \n 電腦課程豐富了我的專業知識，期望接下來的課程可以學到更多的新知識，我期待將學到的技能運用到未來的科技上，並在課程設計上更進一步的成長進步。 \n', 'tags': '', 'url': 'w13.html'}, {'title': '各國國旗', 'text': '#include <stdio.h> \n #include <gd.h> \n \xa0 \n #define WIDTH 600 \n #define HEIGHT 400 \n #define BLACK 0x000000\xa0 // Black color \n #define YELLOW 0xFFD100 // Yellow color \n #define RED 0xED2939\xa0\xa0\xa0 // Red color \n \xa0 \n void   drawBelgiumFlag() { \n \xa0\xa0\xa0\xa0 gdImagePtr im; \n \xa0\xa0\xa0\xa0 FILE   *output; \n \xa0 \n \xa0\xa0\xa0\xa0 im = gdImageCreateTrueColor(WIDTH, HEIGHT); \n \xa0\xa0\xa0\xa0 output =  fopen ( "belgium_flag.png" ,  "wb" ); \n \xa0 \n \xa0\xa0\xa0\xa0 // Allocate black, yellow, and red colors \n \xa0\xa0\xa0\xa0 int   blackIndex = gdImageColorAllocate(im, (BLACK >> 16) & 0xFF, (BLACK >> 8) & 0xFF, BLACK & 0xFF); \n \xa0\xa0\xa0\xa0 int   yellowIndex = gdImageColorAllocate(im, (YELLOW >> 16) & 0xFF, (YELLOW >> 8) & 0xFF, YELLOW & 0xFF); \n \xa0\xa0\xa0\xa0 int   redIndex = gdImageColorAllocate(im, (RED >> 16) & 0xFF, (RED >> 8) & 0xFF, RED & 0xFF); \n \xa0 \n \xa0\xa0\xa0\xa0 // Draw black left third \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(im, 0, 0, WIDTH / 3 - 1, HEIGHT - 1, blackIndex); \n \xa0 \n \xa0\xa0\xa0\xa0 // Draw yellow middle third \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(im, WIDTH / 3, 0, 2 * WIDTH / 3 - 1, HEIGHT - 1, yellowIndex); \n \xa0 \n \xa0\xa0\xa0\xa0 // Draw red right third \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(im, 2 * WIDTH / 3, 0, WIDTH - 1, HEIGHT - 1, redIndex); \n \xa0 \n \xa0\xa0\xa0\xa0 // Save the image \n \xa0\xa0\xa0\xa0 gdImagePng(im, output); \n \xa0\xa0\xa0\xa0 fclose (output); \n \xa0\xa0\xa0\xa0 gdImageDestroy(im); \n } \n \xa0 \n int   main() { \n \xa0\xa0\xa0\xa0 drawBelgiumFlag(); \n \xa0\xa0\xa0\xa0 return   0; \n } \n \n \n \n \n \n \n \n \n \n #include <stdio.h> \n #include <gd.h> \n \xa0 \n int   main() { \n \xa0\xa0\xa0\xa0 int   width = 300;\xa0  // 宽度 \n \xa0\xa0\xa0\xa0 int   height = 200;  // 高度 \n \xa0 \n \xa0\xa0\xa0\xa0 gdImagePtr image = gdImageCreateTrueColor(width, height); \n \xa0 \n \xa0\xa0\xa0\xa0 if   (image == NULL) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 printf ( "Failed to create image.\\n" ); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   1; \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 // 确定颜色索引 \n \xa0\xa0\xa0\xa0 int   green = gdImageColorAllocate(image, 0, 128, 0); \n \xa0\xa0\xa0\xa0 int   white = gdImageColorAllocate(image, 255, 255, 255); \n \xa0\xa0\xa0\xa0 int   red = gdImageColorAllocate(image, 255, 0, 0); \n \xa0 \n \xa0\xa0\xa0\xa0 // 填充颜色 \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(image, 0, 0, width / 3, height, green); \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(image, width / 3, 0, (width / 3) * 2, height, white); \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(image, (width / 3) * 2, 0, width, height, red); \n \xa0 \n \xa0\xa0\xa0\xa0 FILE   *outputFile; \n \xa0\xa0\xa0\xa0 outputFile =  fopen ( "./../images/italian_flag.png" ,  "wb" ); \n \xa0 \n \xa0\xa0\xa0\xa0 if   (outputFile == NULL) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 printf ( "Failed to open file for writing.\\n" ); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   1; \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 gdImagePng(image, outputFile); \n \xa0\xa0\xa0\xa0 fclose (outputFile); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageDestroy(image); \n \xa0 \n \xa0\xa0\xa0\xa0 return   0; \n } \n \n \n \n \n \n \n \n \n \n #include <stdio.h> \n #include <gd.h> \n #include <math.h> \n \xa0 \n #define WIDTH 600 \n #define HEIGHT 400 \n #define RED 0xDC143C\xa0 // Crimson color \n #define YELLOW 0xFFFF00 \n \xa0 \n void   drawStar(gdImagePtr im,  int   x,  int   y,  int   outerRadius,  int   innerRadius,  int   color) { \n \xa0\xa0\xa0\xa0 double   angle = -M_PI / 2.0;\xa0  // Starting angle for the star \n \xa0 \n \xa0\xa0\xa0\xa0 gdPoint starPoints[10]; \n \xa0 \n \xa0\xa0\xa0\xa0 for   ( int   i = 0; i < 10; i++) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 int   radius = i % 2 == 0 ? outerRadius : innerRadius; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 starPoints[i].x = x + radius *  cos (angle); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 starPoints[i].y = y + radius *  sin (angle); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 angle += M_PI / 5.0;\xa0  // Angle between two consecutive points \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageFilledPolygon(im, starPoints, 10, color); \n } \n \xa0 \n void   drawVietnamFlag() { \n \xa0\xa0\xa0\xa0 gdImagePtr im; \n \xa0\xa0\xa0\xa0 FILE   *output; \n \xa0 \n \xa0\xa0\xa0\xa0 im = gdImageCreateTrueColor(WIDTH, HEIGHT); \n \xa0\xa0\xa0\xa0 output =  fopen ( "vietnam_flag.png" ,  "wb" ); \n \xa0 \n \xa0\xa0\xa0\xa0 // Draw red background \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(im, 0, 0, WIDTH - 1, HEIGHT - 1, RED); \n \xa0 \n \xa0\xa0\xa0\xa0 // Draw yellow star in the center \n \xa0\xa0\xa0\xa0 int   starSize = 60; \n \xa0\xa0\xa0\xa0 int   starX = WIDTH / 2; \n \xa0\xa0\xa0\xa0 int   starY = HEIGHT / 2; \n \xa0 \n \xa0\xa0\xa0\xa0 drawStar(im, starX, starY, starSize, starSize / 2, YELLOW); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImagePng(im, output); \n \xa0\xa0\xa0\xa0 fclose (output); \n \xa0\xa0\xa0\xa0 gdImageDestroy(im); \n } \n \xa0 \n int   main() { \n \xa0\xa0\xa0\xa0 drawVietnamFlag(); \n \xa0\xa0\xa0\xa0 return   0; \n } \n \n \n', 'tags': '', 'url': '各國國旗.html'}, {'title': '布萊頓', 'text': 'https://en.wikipedia.org/wiki/Python_（程式語言） \n 例子： \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python教學： \n https://docs.python.org/3/tutorial/ \n Python的平衡介紹 \n 縮排（Python採用4個Spaces縮排，以介面執行範圍） \n 變數（ Python 關鍵字 ） \n 註（#單行註解、三單標註或三雙標註標註多行註解） \n 數 (整數 int(), 浮點數 float()) \n 字串 （字符串） \n print (Python 內建函數,  print() 函數式) \n Python是控制流程工具 \n 為了 \n 如果 \n 範圍 \n 開放 \n 讀 \n 清單 \n 元組 \n 字典 \n 功能 \n 嘗試...除了 \n 休息時間 \n 曾經 \n 類別 \n 此頁面示範如何在同一頁面下加入多個線上Ace編輯器與執行按鈕（ practice_html.txt 動態頁面超檔案）。 \n Practice_html.txt 動態頁面超檔案應該可以在啟動Brython時，設定分割.py檔案放入downloads/py目錄中引用。 \n 也所有即將出現的對應 html 也使用 Brython 產生，然後編寫為 類別 後，在範例匯入時交叉 實例 引用。 \n <!-- 啟動 Brython --> \n<腳本> \n視窗.onload=函數(){ \nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']}); \n} \n</> 腳本 \n 從1累加到100： \n 1加到100 \n 將 iterable 與 iterator 相關說明 ，利用 Brython 與 Ace Editor 整理頁面。 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從1累加到100第2部分： \n 1加到100 cango_三_齒輪 BS蛇 人工智能俄羅斯區塊鏈 旋轉塊 \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': '布萊頓.html'}]};